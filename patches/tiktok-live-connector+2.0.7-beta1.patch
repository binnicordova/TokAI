diff --git a/node_modules/tiktok-live-connector/dist/lib/client.js b/node_modules/tiktok-live-connector/dist/lib/client.js
index f707eae..673e453 100644
--- a/node_modules/tiktok-live-connector/dist/lib/client.js
+++ b/node_modules/tiktok-live-connector/dist/lib/client.js
@@ -149,14 +149,18 @@ class TikTokLiveConnection extends node_events_1.EventEmitter {
      * @returns The current connection state
      */
     async connect(roomId) {
+        console.log('LOG roomId', roomId);
         switch (this._connectState) {
             case events_1.ConnectState.CONNECTED:
+                console.log('events_1.ConnectState.CONNECTED');
                 throw new errors_1.AlreadyConnectedError('Already connected!');
             case events_1.ConnectState.CONNECTING:
+                console.log('events_1.ConnectState.CONNECTING');
                 throw new errors_1.AlreadyConnectingError('Already connecting!');
             default:
             case events_1.ConnectState.DISCONNECTED:
                 try {
+                    console.log('events_1.ConnectState.DISCONNECTED');
                     this._connectState = events_1.ConnectState.CONNECTING;
                     await this._connect(roomId);
                     this._connectState = events_1.ConnectState.CONNECTED;
@@ -164,9 +168,17 @@ class TikTokLiveConnection extends node_events_1.EventEmitter {
                     return this.state;
                 }
                 catch (err) {
-                    this._connectState = events_1.ConnectState.DISCONNECTED;
-                    this.handleError(err, 'Error while connecting');
-                    throw err;
+                    console.log('catch error', err);
+                    if (errors_1.AlreadyConnectedError && err instanceof errors_1.AlreadyConnectedError) {
+                        console.log('Already connected error occurred');
+                    } else if (errors_1.AlreadyConnectingError && err instanceof errors_1.AlreadyConnectingError) {
+                        console.log('Already connecting error occurred');
+                    } else {
+                        console.log('catch error', err);
+                        this._connectState = events_1.ConnectState.DISCONNECTED;
+                        this.handleError(err, 'Error while connecting');
+                        throw err;
+                    }
                 }
         }
     }
@@ -178,6 +190,7 @@ class TikTokLiveConnection extends node_events_1.EventEmitter {
      */
     async _connect(roomId) {
         // First we set the Room ID
+        console.log('_connect roomId', roomId);
         if (!this.options.connectWithUniqueId || this.options.fetchRoomInfoOnConnect || this.options.enableExtendedGiftInfo) {
             this.clientParams.room_id = roomId || this.clientParams.room_id || await this.fetchRoomId();
         }
@@ -198,6 +211,7 @@ class TikTokLiveConnection extends node_events_1.EventEmitter {
             uniqueId: this.options.connectWithUniqueId ? this.uniqueId : undefined,
             sessionId: this.options.authenticateWs ? this.options.sessionId : undefined
         });
+        console.log('protoMessageFetchResult', protoMessageFetchResult);
         // <Optional> Process the initial data
         if (this.options?.processInitialData) {
             await this.processProtoMessageFetchResult(protoMessageFetchResult);
@@ -217,9 +231,12 @@ class TikTokLiveConnection extends node_events_1.EventEmitter {
             cursor: protoMessageFetchResult.cursor,
             ...protoMessageFetchResult.wsParams
         };
+        console.log('wsParams', wsParams);
         this.wsClient = await this.setupWebsocket(protoMessageFetchResult.wsUrl, wsParams);
         // Default app behaviour is to send the im_enter_room message on WebSocket connect
+        console.log('this.roomId', this.roomId);
         this.wsClient.switchRooms(this.roomId);
+        console.log('EMIT WEBSOCKET_CONNECTED');
         this.emit(events_1.ControlEvent.WEBSOCKET_CONNECTED, this.wsClient);
     }
     /**
@@ -332,7 +349,7 @@ class TikTokLiveConnection extends node_events_1.EventEmitter {
      */
     async waitUntilLive(seconds = 60) {
         seconds = Math.max(30, seconds);
-        return new Promise(async (resolve) => {
+        return new Promise((resolve) => {
             const fetchIsLive = async () => {
                 const isLive = await this.fetchIsLive();
                 if (isLive) {
@@ -340,8 +357,10 @@ class TikTokLiveConnection extends node_events_1.EventEmitter {
                     resolve();
                 }
             };
-            const interval = setInterval(async () => fetchIsLive(), seconds * 1000);
-            await fetchIsLive();
+            const interval = setInterval(() => {
+                fetchIsLive();
+            }, seconds * 1000);
+            fetchIsLive();
         });
     }
     /**
@@ -360,7 +379,7 @@ class TikTokLiveConnection extends node_events_1.EventEmitter {
      */
     async fetchAvailableGifts() {
         try {
-            let response = await this.webClient.getJsonObjectFromWebcastApi('gift/list/', this.clientParams);
+            const response = await this.webClient.getJsonObjectFromWebcastApi('gift/list/', this.clientParams);
             return response.data.gifts;
         }
         catch (err) {
@@ -403,19 +422,30 @@ class TikTokLiveConnection extends node_events_1.EventEmitter {
      */
     async setupWebsocket(wsUrl, wsParams) {
         return new Promise((resolve, reject) => {
+            console.log('setupWebsocket', wsUrl);
             // Instantiate the client
             const wsClient = new ws_client_1.default(wsUrl, this.webClient.cookieJar, { ...config_1.default.DEFAULT_WS_CLIENT_PARAMS, ...this.options.wsClientParams, ...wsParams }, { ...config_1.default.DEFAULT_WS_CLIENT_HEADERS, ...this.options?.wsClientHeaders }, this.options?.wsClientOptions);
+            console.log('wsClient created');
             // Handle the connection
             wsClient.on('open', () => {
+                console.log('WebSocket connection established');
                 clearTimeout(connectTimeout);
-                wsClient.on('error', (e) => this.handleError(e, 'WebSocket Error'));
+                console.log('clearTimeout(connectTimeout);');
+                wsClient.on('error', (e) => {
+                    console.log('WebSocket error event', e);
+                    this.handleError(e, 'WebSocket Error')
+                });
                 wsClient.on('close', () => {
+                    console.log('WebSocket connection closed');
                     this.setDisconnected();
                     this.emit(events_1.ControlEvent.DISCONNECTED);
                 });
                 resolve(wsClient);
             });
-            wsClient.on('error', (err) => reject(`Websocket connection failed, ${err}`));
+            wsClient.on('error', (err) => {
+                console.error('WebSocket connection error event', err);
+                reject(`Websocket connection failed, ${err}`);
+            });
             wsClient.on('protoMessageFetchResult', this.processProtoMessageFetchResult.bind(this));
             wsClient.on('imEnteredRoom', (data) => this.emit(events_1.ControlEvent.ENTER_ROOM, data));
             wsClient.on('webSocketData', (data) => this.emit(events_1.ControlEvent.WEBSOCKET_DATA, data));
@@ -442,33 +472,33 @@ class TikTokLiveConnection extends node_events_1.EventEmitter {
     async processDecodedData({ data, type }) {
         // Emit a decoded data event
         switch (type) {
-            case 'WebcastSocialMessage':
+            case 'WebcastSocialMessage': {
                 if (data.common.displayText.displayType?.includes('follow')) {
                     return this.emit(events_1.WebcastEvent.FOLLOW, data);
                 }
                 if (data.common.displayText.displayType?.includes('share')) {
                     return this.emit(events_1.WebcastEvent.SHARE, data);
                 }
-                // First, emit the raw social message
                 return this.emit(events_1.WebcastEvent.SOCIAL, data);
-            case 'WebcastControlMessage':
-                // Send raw message
+            }
+            case 'WebcastControlMessage': {
                 this.emit(events_1.WebcastEvent.CONTROL_MESSAGE, data);
                 if (data.action === types_1.ControlAction.CONTROL_ACTION_STREAM_ENDED || data.action === types_1.ControlAction.CONTROL_ACTION_STREAM_SUSPENDED) {
                     this.emit(events_1.WebcastEvent.STREAM_END, { action: data.action });
                     await this.disconnect();
                 }
                 return;
-            case 'WebcastGiftMessage':
-                // Add extended gift info if available
+            }
+            case 'WebcastGiftMessage': {
                 if (Array.isArray(this.availableGifts) && data.giftId) {
                     data.extendedGiftInfo = this.availableGifts.find((x) => x.id === data.giftId);
                 }
                 return this.emit(events_1.WebcastEvent.GIFT, data);
-            default:
-                // Handle all other events
+            }
+            default: {
                 const basicEvent = events_1.WebcastEventMap[type];
                 return basicEvent && this.emit(basicEvent, data);
+            }
         }
     }
     /**
diff --git a/node_modules/tiktok-live-connector/dist/lib/ws/lib/ws-client.js b/node_modules/tiktok-live-connector/dist/lib/ws/lib/ws-client.js
index 194716b..00a5e18 100644
--- a/node_modules/tiktok-live-connector/dist/lib/ws/lib/ws-client.js
+++ b/node_modules/tiktok-live-connector/dist/lib/ws/lib/ws-client.js
@@ -6,33 +6,45 @@ Object.defineProperty(exports, "__esModule", { value: true });
 const utilities_1 = require("../../../lib/utilities");
 const config_1 = __importDefault(require("../../../lib/config"));
 const types_1 = require("../../../types");
-const ws_1 = require("ws");
+const WebSocket = require("../../../../../../shims/ws");
 const textEncoder = new TextEncoder();
-class TikTokWsClient extends ws_1.WebSocket {
+class TikTokWsClient extends WebSocket {
     webSocketParams;
     webSocketPingIntervalMs;
     pingInterval;
     constructor(wsUrl, cookieJar, webSocketParams, webSocketHeaders, webSocketOptions, webSocketPingIntervalMs = 10000) {
+        console.log('TikTokWsClient constructor', wsUrl, webSocketParams);
         const wsHeaders = { Cookie: cookieJar.getCookieString(), ...(webSocketHeaders || {}) };
-        const wsUrlWithParams = `${wsUrl}?${new URLSearchParams(webSocketParams)}${config_1.default.DEFAULT_WS_CLIENT_PARAMS_APPEND_PARAMETER}`;
+        console.log('wsHeaders', wsHeaders);
+        let wsUrlWithParams;
+        try {
+            wsUrlWithParams = `${wsUrl}?${new URLSearchParams(webSocketParams)}${config_1.default.DEFAULT_WS_CLIENT_PARAMS_APPEND_PARAMETER}`;
+        } catch (error) {
+            console.error('Error constructing WebSocket URL with parameters:', error);
+        }
+        console.log('wsUrlWithParams', wsUrlWithParams);
         super(wsUrlWithParams, {
             headers: wsHeaders,
             host: `https://${config_1.default.TIKTOK_HOST_WEB}`,
             ...webSocketOptions,
             autoPong: false
         });
+        console.log('TikTokWsClient super called');
         this.webSocketParams = webSocketParams;
         this.webSocketPingIntervalMs = webSocketPingIntervalMs;
         this.pingInterval = null;
+        console.log('TikTokWsClient super done');
         this.on('open', this.onOpen.bind(this));
         this.on('message', this.onMessage.bind(this));
         this.on('close', this.onDisconnect.bind(this));
     }
     onOpen() {
+        console.log('WebSocket connection opened, starting heartbeat');
         this.sendHeartbeat();
         this.pingInterval = setInterval(() => this.sendHeartbeat(), this.webSocketPingIntervalMs);
     }
     get open() {
+        console.log('WebSocket readyState', this.readyState, 'OPEN:', ws_1.WebSocket.OPEN);
         return this.readyState === ws_1.WebSocket.OPEN;
     }
     /**
@@ -87,7 +99,7 @@ class TikTokWsClient extends ws_1.WebSocket {
         // Create the heartbeat
         const hb = types_1.HeartbeatMessage.encode({ roomId: room_id });
         // Wrap it in the WebcastPushFrame
-        const webcastPushFrame = (0, utilities_1.createBaseWebcastPushFrame)({
+        const webcastPushFrame = utilities_1.createBaseWebcastPushFrame({
             payloadEncoding: 'pb',
             payloadType: 'hb',
             payload: hb.finish(),
